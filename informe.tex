\documentclass{article}

\usepackage{graphicx}
% Links
\usepackage[pdftex, colorlinks, urlcolor=blue, linkcolor=black]{hyperref}
% Para el español
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
% Codigo
\usepackage{listings}
% Para el código en Go.
\usepackage{lstlang0}
% Colores personalizados.
\usepackage{color}
\definecolor{orange}{rgb}{0.99, 0.50, 0.13}
\definecolor{carnelian}{rgb}{0.7, 0.11, 0.11}
\definecolor{cerulean}{rgb}{0.0, 0.48, 0.65}
\definecolor{royalblue}{rgb}{0.0, 0.14, 0.4}
\definecolor{shamrockgreen}{rgb}{0.0, 0.62, 0.38}
% Settings para los fragmentos de código.
\renewcommand{\lstlistingname}{Fragmento}
\lstset{
	language = go,
	numbers = left,
	%Keywords
	keywordstyle = {[1]\color{orange}\bfseries},
	%Funciones
	keywordstyle = {[2]\color{shamrockgreen}\bfseries},
	%Tipos
	keywordstyle = {[3]\color{royalblue}},
	stringstyle = \color{carnelian},
	commentstyle = \color{cerulean},
	frame = tb,
	showstringspaces = false,
	breaklines = true,
}

\begin{document}

\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{./logo_fiuba_alta}
	\label{fig:logo_fiuba_alta}
\end{figure}

\title{Informe sobre GO - Teoría del Lenguaje}
\author{Cristian Gonzalez \and Tomás Arjovsky}
\date{1$^{er}$ Cuatrimestre, 2015}
\maketitle
\section{Historia}
% y un poco de lo general.
% Compilador, formateador de codigo y demas.
% Errores por no usar variables en lugar de warnings.
\section{Sintaxis Básica}
\subsection{Paquetes}
Cada archivo de código fuente, independientemente de su nombre, aclara en la primera línea a qué paquete pertenece.

Si se quiere acceder desde un paquete a otro, lo que se hace es importar su path. Por convención, los paquetes se llaman como el último elemento del path. Importar un paquete permite usar los nombres que este exporta, típicamente funciones o variables globales (al paquete). Para señalar que un elemento se exporta, su nombre comienza con mayúscula.

Un proyecto comienza a ejecutarse en la función main del paquete main.

\lstinputlisting[caption="Hello World en Go"]{codigo/helloWorld.go}

Se puede importar más de un paquete con la forma factoreada. Esta forma es utilizada también para otras keywords además de import, como var.

\begin{lstlisting}[caption=Forma Factoreada]
import (
	"fmt" 
	"math"
)
\end{lstlisting}

\subsection{Variables}
Las variables en Go son declaradas de forma inversa al C, pareciéndose más a la de Pascal. Esta decisión fue tomada por los creadores principalmente por la dificultad para entender en C los tipos compuestos con punteros y las funciones de alto orden\cite{dec}.
\begin{description}
	\item[Declaración:]\hfill \\
		\lstinline|var a,b,c int|
	\item[Inicialización en declaración:] \hfill \\
		\lstinline|var a,b,c int = 1,2,3 // Hay asignacion multiple!|
	\item[Inferencia de Tipos:] para constantes y variables. \\
		\lstinline|var c = 1 // c pasa a ser de tipo int.|
	\item[Forma Compacta:] \hfill \\
		\lstinline|c := 1 // c se declara y se asigna.|
	
	Esta forma se puede usar siempre y cuando se esté dentro de una función (main incluida). Esto se debe a que globalmente (a nivel paquete) todas las líneas deben empezar con alguna keyword. 
	\item[Forma Factoreada:] La keyword \lstinline|var| también admite forma factoreada.
\begin{lstlisting}
var (
	a = 3 // inferencia sobre constante.
	b = a // inferencia sobre variable que ya tiene tipo.
)
\end{lstlisting}
\end{description}

Al asignar en Go una variable a la otra, se asigna el valor, al estilo imperativo, con lo cual cambiar una no tendrá ningún efecto sobre la otra (como sí sucedería en los lenguajes como Java, donde las variables son referencias).

Los punteros se declaran de la forma \lstinline|var a *int|. A diferencia de C, \emph{no hay aritmética de punteros}. Esta omisión fue pensada para aumentar la seguridad (evitar direcciones ilegales) y simplificar la implementación del recolector de basura.\cite{pa}
%TODO ver el tema del make, que no se puede hacer personalizado.

\subsection{Funciones}
No se declaran a través de su tipo de retorno, como se hace en C, sino que tienen la keyword \lstinline|func|.
\begin{description}
	\item[Declaración:]\hfill \\
		\lstinline|func nombre(a tA, b tB,...) tRet {...}| 
	\item[Argumentos agrupados según tipo:] \hfill \\
		\lstinline|func nombre(a, b int) int {...}|
	\item[Retorno Múltiple:] compatible con la asignación múltiple. \\
		\lstinline|func swap(a, b int) int {return b,a}|
	\item[Return Values como variables:] se pueden modificar en el interior de la función y al final usar "return" las devuelve en el orden especificado en la firma.
\begin{lstlisting}[caption = una variable elevada al cuadrado 3 veces]
func primeros3Cuadrados.(a int) m1,m2,m3 int{
	m1 = a*a
	m2 = m1*m1
	m3 = m2*m2
	return
}
\end{lstlisting}
\end{description}

\subsection{Estructuras de Control}
\subsubsection{Loops: for}
La única estructura de control de ciclos en Go es el \lstinline|for|, que es lo suficientemente flexible y cómodo como para reemplazar al while(), do{}While() y otros. Una diferencia menor es que los paréntesis ya no se usan y las llaves son obligatorias.
\begin{description}
	\item[Forma clásica:] \hfill \\
		\lstinline|for i := 0; i < 10; i++ { fmt.Println(i) }|
	\item[Omisiones:] El pre y el post pueden no ponerse (cualquier combinación es válida). Cuando queda solo la condición de corte, se da el caso que reemplaza al while: \\
		\lstinline|for a < 1000 { a = a*a }|
	\item[range:] para operar sobre arrays y slices (más adelante se ven), se puede usar \lstinline|range|. Es una forma primitiva que, junto a la función \lstinline|len|, elimina la necesidad de máximos lógicos, constantes o variables referidas al tamaño. Se pueden omitir el índice o el valor con el operador \_:
	\begin{itemize}
	\item \lstinline|for i,v := range arreglo {fmt.Println("indice:",i,"valor:",v)}|
	\item \lstinline|for i := range arreglo {fmt.Println("indice:",i)}|
	\item \lstinline|for _,v := range arreglo {fmt.Println("valor:",v)}|
	\end{itemize}
\end{description}
\subsubsection{if}
Igual que el clásico de C o C++, solo que se sigue el mismo criterio con los paréntesis y las llaves y se puede agregar un pre (paso inicial, previo al if), al igual que en el for. De la misma forma, \emph{cualquier variable definida en el pre vivirá solo en el scope del if (y del else)}. %TODO ver si hay otra forma de decir pre y post.
\begin{lstlisting}[caption = promedio precalculado.]
// Al calcular p en el pre, no hay que calcularlo de nuevo adentro del if.
if p := prom(notas); p >= 7 {
	fmt.Println("Aprobado. Promedio:", p)
} else {
	fmt.Println("Reprobado. Promedio:", p)
}
\end{lstlisting}

\subsubsection{switch}
Se agrega un break automático al final de cada case. Entonces, a diferencia de C, para casos múltiples, en lugar de omitir un break, se hacen conjuntos separados por coma. Además, las expresiones de cada caso son más generales, ya que no necesitan ser constantes o siquiera enteros. 

\begin{lstlisting}[caption = parsear acciones de T.E.G. (switch sobre strings)]
switch accion {
	case "invadir": invadir(objetivo)
	case "reagrupar": reagrupar()
	case "pedir tarjeta", "tarjeta": sacarCarta(mazo)
	default: fmt.Println("Opcion desconocida")
}
\end{lstlisting}
Si no se especifica ninguna variable en el switch se asume \lstinline|switch true|, con lo cual se evalúan expresiones booleanas. Como los casos se evalúan de arriba hacia abajo en orden, el switch a secas es una forma prolija de anidar ifs.

\begin{lstlisting}[caption = switch como ifs anidados.]
switch {
	p < 4: fmt.Println("aplazado")
	p < 7: fmt.Println("reprobado")
	default: fmt.Println("aprobado")
}
\end{lstlisting}

\subsubsection{defer}
Una función a la que se le antepone \lstinline|defer| (posponer, diferir) se ejecuta al final de la función que la contiene. Si hay \lstinline|defer| con más de una función, se ejecutan de forma LIFO.

\lstinputlisting[firstline = 5, caption = Hello World Alternativo]{codigo/defer.go}

Una gran utilidad del defer es, dentro de las funciones que tienen muchos return en distintas circunstancias, usar una función diferida que tiene que ejecutarse en todos los casos de devolución, como por ejemplo, cerrar un archivo. \cite{defer}

\section{Tipos de datos}
Go tiene tipado estático (en tiempo de compilación) y fuerte. Las variables o bien son declaradas con un cierto tipo o lo infieren de la parte derecha de una asignación, luego de lo cual no pueden cambiar su tipo. Lo más parecido a tipado dinámico son las interfaces, que se verán más adelante.

Estos son los tipos básicos de Go:
\begin{description}
\item[Booleanos:] \lstinline|bool|.
\item[Cadenas:] \lstinline|string|.
\item[Enteros:] \lstinline|int  int8  int16  int32  int64|.
\item[Sin signo:] \lstinline|uint uint8 uint16 uint32 uint64 uintptr|.
\item[Bytes:] \lstinline|byte|. Alias de uint8.
\item[Caracteres:] \lstinline|rune|. Alias de int32, se verá más adelante, representa un punto de Unicode.
\item[Flotantes:] \lstinline|float32 float64|
\item[Complejos:] \lstinline|complex64 complex128|
\end{description}

Cada tipo tiene un \emph{zero value}, que es un valor en el que se inicializa la variable si no se especifica uno al declararla. Para los valores numéricos es 0, para las strings, la cadena vacía y para estructuras complejas suele ser nil.

%TODO ver casos raros para inferencia, como variables que todavía no tienen valor, y demás.
La \emph{inferencia} es bastante simple, ya que es un lenguaje tipado. Cuando se usa el operador := con una variable del lado derecho, la del lado izquierdo adquiere su mismo tipo. 

El caso más raro es el de las constantes numéricas, que son de alta precisión y no tienen un tipo, sino que proveen el tipo necesario para las operaciones que se hagan sobre ellas. 
\lstinputlisting[caption = Constantes Comodines]{codigo/constantes.go}
El caso anterior produce el siguiente output: 
\begin{verbatim}
La variable es de tipo int y tiene valor: 5.
La variable es de tipo float32 y tiene valor: 5.
La variable es de tipo float32 y tiene valor: 5e+19.
\end{verbatim}
Esto muestra justamente lo propuesto de que la constante provee el tipo necesitado. Sin embargo, esto tiene sus excepciones, como es el caso de c2. Esta constante es un número muy grande como para  proveer un valor de tipo int, con lo cual si se quitan las barras de comentario de la última línea del main, el programa falla en tiempo de compilación: 

\begin{verbatim}
./constantes.go:20: constant 50000000000000000000 overflows int
\end{verbatim}

Como se decía antes, hay que notar que este comportamiento de comodín es \emph{solo para constantes}. La conversión de tipos entre variables es \emph{siempre explícita}.

\lstinputlisting[caption = asignación ilegal.]{codigo/variables.go}
Produce el siguiente mensaje de error:
\begin{verbatim}
./variables.go:6: cannot use entera (type int) as type float32 in assignment
\end{verbatim}
Para hacerlo correctamente hay que explicitar la conversión:
\lstinputlisting[caption = conversión legal.]{codigo/variablesbien.go}

Si creamos tipos propios o queremos hacer funciones que conviertan de un tipo a otro que son muy distintos, podemos hacer uso de interfaces y switches sobre tipos. Más adelante %TODO linkear
se explica este caso.

En adelante se detallan algunos tipos de datos específicos:

\subsection{Structs}
Prácticamente iguales a los de C. Para usarlos, se define un tipo basado en struct de la siguiente manera:
\begin{lstlisting}[caption = declaración de structs]
type vertice struct{
	x int
	y int
	z int
}
\end{lstlisting}

Son la forma empaquetada nativa de Go. Se pueden asignar structs literales de la siguiente forma: \lstinline| v := vertice{1,2,3}|. Se puede inicializar un campo específico (\lstinline|v := vertice{x:1, z:2}|) y los que queden sin asignar tendrán zero values.

Para acceder a sus campos se usa, por ejemplo para el x, v.x.

\paragraph{Transparencia de punteros:} los punteros a registros son transparentes para el acceso a los campos:

\begin{lstlisting}[caption = transparencia de punteros.]
pv := &vertice{10,20,30} // se crea un puntero a un vertice.
fmt.Println(pv.x) // se imprime el primer campo (10).
\end{lstlisting}
\subsection{Arrays}
La forma básica de almacenamiento secuencial. Más allá de su implementación interna, una variable que es un array, \emph{no es un puntero}. Si se hace un puntero al array no apunta a su primer elemento, si no a la variable que lo contiene (recordar que no hay aritmética de punteros).
\begin{description}
	\item[Declaracion:] \hfill \\
	\lstinline|var arr [5]int // 5 es el "element count"|\\
	Es importante tener en cuenta que el element count es parte del tipo: [5]int y [6]int son tipos diferentes.
	\item[Literales:] \hfill \\
		\lstinline|arr := [5]int{1,2,3,4,5}|
	\item[Conteo automático:] a través del operador ``...'' \\
		\lstinline|arr := [...]int{1,2,3,4,5}|
\end{description}

Como última nota: si a un array no se le especifican valores con una inicialización, todas sus posiciones son inicializadas en el zero value del tipo base.
\subsection{Slices}
Forma dinámica secuencial nativa de Go. %TODO terminar.
\subsection{Runas y strings}
\subsection{Funciones y clausuras}

\section{Recolector de Basura}
El Recolector de Basura de Go usa una variante de \textit{marcado-y-barrido} donde en vez de usar solamente 2 colores para el marcado, usa 3. 
Acá explicamos las características de cada conjunto.
\begin{itemize}
	\item[$\bullet$] Gris:
	\item Negro: El conjunto negro es el conjunto de objetos que pueden ser mostrados por tener referencias salientes a los objetos en el conjunto blanco, y por ser accesible desde la raíz. Los negros no son candidatos a reciclar, en algunas implementaciones el conjunto negro empieza vacío. 
	\item Blanco: son aquellos que son candidatos a reciclar. En un principio todos son candidatos a reciclar. 
\end{itemize}

Otra característica importante es \textit{stop-the-world} el cual pausa, al momento de correr el recolector, todos los hilos menos aquellos que utilice el recolector hasta que finalice el mismo. 

\begin{thebibliography}{99}
\bibitem{dec} Nota en The Go Blog sobre la \href{http://blog.golang.org/gos-declaration-syntax}{sintáxis de la declaración}.
\bibitem{pa} FAQ sobre \href{https://golang.org/doc/faq#no_pointer_arithmetic}{aritmética de punteros}.
\bibitem{defer} Effective Go sobre \href{https://golang.org/doc/effective_go.html#defer}{el uso del defer}
\end{thebibliography}

\end{document}