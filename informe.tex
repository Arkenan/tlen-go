\documentclass{article}

\usepackage{graphicx}
% Links
\usepackage[pdftex, colorlinks, urlcolor=blue, linkcolor=black]{hyperref}
% Para el español
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
% Codigo
\usepackage{listings}
% Para el código en Go.
\usepackage{lstlang0}
% Colores personalizados.
\usepackage{color}
\definecolor{orange}{rgb}{0.99, 0.50, 0.13}
\definecolor{carnelian}{rgb}{0.7, 0.11, 0.11}
\definecolor{cerulean}{rgb}{0.0, 0.48, 0.65}
\definecolor{royalblue}{rgb}{0.0, 0.14, 0.4}
\definecolor{shamrockgreen}{rgb}{0.0, 0.62, 0.38}
% Settings para los fragmentos de código.
\renewcommand{\lstlistingname}{Fragmento}
\lstset{
	language = go,
	numbers = left,
	%Keywords
	keywordstyle = {[1]\color{orange}\bfseries},
	%Funciones
	keywordstyle = {[2]\color{shamrockgreen}\bfseries},
	%Tipos
	keywordstyle = {[3]\color{royalblue}},
	stringstyle = \color{carnelian},
	commentstyle = \color{cerulean},
	frame = tb,
	showstringspaces = false,
	breaklines = true,
}

\begin{document}

\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{./logo_fiuba_alta}
	\label{fig:logo_fiuba_alta}
\end{figure}

\title{Informe sobre GO - Teoría del Lenguaje}
\author{Cristian Gonzalez \and Tomás Arjovsky}
\date{1$^{er}$ Cuatrimestre, 2015}
\maketitle
\section{Historia}
% y un poco de lo general.
% Compilador, formateador de codigo y demas.

\section{Sintaxis Básica}
\subsection{Paquetes}
Cada archivo de código fuente, independientemente de su nombre, aclara en la primera línea a qué paquete pertenece.

Si se quiere acceder desde un paquete a otro, lo que se hace es importar su path. Por convención, los paquetes se llaman como el último elemento del path. Importar un paquete permite usar los nombres que este exporta, típicamente funciones o variables globales (al paquete). Para señalar que un elemento se exporta, su nombre comienza con mayúscula.

Un proyecto comienza a ejecutarse en la función main del paquete main.

\lstinputlisting[caption="Hello World en Go"]{codigo/helloWorld.go}

Se puede importar más de un paquete con la forma factoreada. Esta forma es utilizada también para otras keywords además de import, como var.

\begin{lstlisting}[caption=Forma Factoreada]
import (
	"fmt" 
	"math"
)
\end{lstlisting}

\subsection{Variables}
Las variables en Go son declaradas de forma inversa al C, pareciéndose más a la de Pascal. Esta decisión fue tomada por los creadores principalmente por la dificultad para entender en C los tipos compuestos con punteros y las funciones de alto orden\cite{dec}.
\begin{description}
	\item[Declaración:]\hfill \\
		\lstinline|var a,b,c int|
	\item[Inicialización en declaración:] \hfill \\
		\lstinline|var a,b,c int = 1,2,3 // Hay asignacion multiple!|
	\item[Inferencia de Tipos:] para constantes y variables. \\
		\lstinline|var c = 1 // c pasa a ser de tipo int.|
	\item[Forma Compacta:] \hfill \\
		\lstinline|c := 1 // c se declara y se asigna.|
	
	Esta forma se puede usar siempre y cuando se esté dentro de una función (main incluida). Esto se debe a que globalmente (a nivel paquete) todas las líneas deben empezar con alguna keyword. 
	\item[Forma Factoreada:] La keyword \lstinline|var| también admite forma factoreada.
\begin{lstlisting}
var (
	a = 3 // inferencia sobre constante.
	b = a // inferencia sobre variable que ya tiene tipo.
)
\end{lstlisting}
\end{description}

Al asignar en Go una variable a la otra, se asigna el valor, al estilo imperativo, con lo cual cambiar una no tendrá ningún efecto sobre la otra (como si sucedería en los lenguajes como Java, donde las variables son referencias).

Los punteros se declaran de la forma \lstinline|var a *int|. A diferencia de C, \emph{no hay aritmética de punteros}. Esta omisión fue pensada para aumentar la seguridad (evitar direcciones ilegales) y simplificar la implementación del recolector de basura.\cite{pa}
%TODO ver el tema del make, que no se puede hacer personalizado.

\subsection{Funciones}
No se declaran a través de su tipo de retorno, como se hace en C, sino que tienen la keyword \lstinline|func|.
\begin{description}
	\item[Declaración:]\hfill \\
		\lstinline|func nombre(a tA, b tB,...) tRet {...}| 
	\item[Argumentos agrupados según tipo:] \hfill \\
		\lstinline|func nombre(a, b int) int {...}|
	\item[Retorno Múltiple:] compatible con la asignación múltiple. \\
		\lstinline|func swap(a, b int) int {return b,a}|
	\item[Return Values como variables:] se pueden modificar en el interior de la función y al final usar "return" las devuelve en el orden especificado en la firma.
\begin{lstlisting}[caption = una variable elevada al cuadrado 3 veces]
func primeros3Cuadrados.(a int) m1,m2,m3 int{
	m1 = a*a
	m2 = m1*m1
	m3 = m2*m2
	return
}
\end{lstlisting}
\end{description}

\subsection{Estructuras de Control}
\subsubsection{Loops: for}
La única estructura de control de ciclos en Go es el \lstinline|for|, que es lo suficientemente flexible y cómodo como para reemplazar al while(), do{}While() y otros. Una diferencia menor es que los paréntesis ya no se usan y las llaves son obligatorias.
\begin{description}
	\item[Forma clásica:] \hfill \\
		\lstinline|for i := 0; i < 10; i++ { fmt.Println(i) }|
	\item[Omisiones:] El pre y el post pueden no ponerse (cualquier combinación es válida). Como queda solo la condición de corte, este es el caso que reemplaza al while. Ej: \\
		\lstinline|for a < 1000 { a = a*a }|
	\item[range:] para operar sobre arrays y slices (más adelante se ven), se puede usar \lstinline|range|. Es una forma primitiva que, junto a la función \lstinline|len| elimina la necesidad de máximos lógicos, constantes o variables referidas al tamaño. Se pueden omitir el índice o el valor con el operador \_:
	\begin{itemize}
	\item \lstinline|for i,v := range arreglo {fmt.Println("indice:",i,"valor:",v)}|
	\item \lstinline|for i := range arreglo {fmt.Println("indice:",i)}|
	\item \lstinline|for _,v := range arreglo {fmt.Println("valor:",v)}|
	\end{itemize}
\end{description}
\subsubsection{if}
Igual que el clásico de C o C++, solo que se sigue el mismo criterio con los paréntesis y las llaves y se puede agregar un pre (paso inicial, previo al if), al igual que en el for. Al igual que para el for, \emph{cualquier variable definida en el pre vivirá solo en el scope del if (y del else)}. %TODO ver si hay otra forma de decir pre y post.
\begin{lstlisting}[caption = promedio precalculado.]
// Al calcular p en el pre, no hay que calcularlo de nuevo adentro del if.
if p := prom(notas); p >= 7 {
	fmt.Println("Aprobado. Promedio:", p)
} else {
	fmt.Println("Reprobado. Promedio:", p)
}
\end{lstlisting}

\subsubsection{switch}
Se agrega un break automático al final de cada case. Entonces, a diferencia de C, para casos múltiples, en lugar de omitir un break, se hacen conjuntos separados por coma. Además, las expresiones de cada caso son más generales, ya que no necesitan ser constantes o siquiera enteros. 

\begin{lstlisting}[caption = parsear de acciones de T.E.G. (strings)]
switch accion {
	case "invadir": invadir(objetivo)
	case "reagrupar": reagrupar()
	case "pedir tarjeta", "tarjeta": sacarCarta(mazo)
	default: fmt.Println("Opcion desconocida")
}
\end{lstlisting}
Si no se especifica ninguna variable en el switch se asume \lstinline|switch true|, con lo cual se evalúan expresiones booleanas. Como los casos se evalúan de arriba hacia abajo en orden, el switch a secas es una forma prolija de anidar ifs.

\begin{lstlisting}[caption = switch como ifs anidados.]
switch {
	p < 4: fmt.Println("aplazado")
	p < 7: fmt.Println("reprobado")
	default: fmt.Println("aprobado")
}
\end{lstlisting}

\subsubsection{defer}
Una función a la que se le antepone \lstinline|defer| (posponer) se ejecuta al final de la función que la contiene. Si hay \lstinline|defer| con más de una función, se ejecutan de forma LIFO.

\lstinputlisting[firstline = 5, caption = Hello World Alternativo]{codigo/defer.go}

\section{Recolector de Basura}
El Recolector de Basura de Go usa una variante de \textit{marcado-y-barrido} donde en vez de usar solamente 2 colores para el marcado, usa 3. 
Acá explicamos las características de cada conjunto.
\begin{itemize}
	\item[$\bullet$] Gris:
	\item Negro: El conjunto negro es el conjunto de objetos que pueden ser mostrados por tener referencias salientes a los objetos en el conjunto blanco, y por ser accesible desde la raíz. Los negros no son candidatos a reciclar, en algunas implementaciones el conjunto negro empieza vacío. 
	\item Blanco: son aquellos que son candidatos a reciclar. En un principio todos son candidatos a reciclar. 
\end{itemize}

Otra característica importante es \textit{stop-the-world} el cual pausa, al momento de correr el recolector, todos los hilos menos aquellos que utilice el recolector hasta que finalice el mismo. 

\begin{thebibliography}{99}
\bibitem{dec} Nota en The Go Blog sobre la \href{http://blog.golang.org/gos-declaration-syntax}{sintáxis de la declaración}.
\bibitem{pa} FAQ sobre \href{https://golang.org/doc/faq#no_pointer_arithmetic}{aritmética de punteros}.
\end{thebibliography}

\end{document}