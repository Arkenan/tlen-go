\documentclass{article}

\usepackage{graphicx}
% Links
\usepackage[pdftex, colorlinks, urlcolor=blue, linkcolor=black]{hyperref}
% Para el español
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
% Codigo
\usepackage{listings}
% Para el código en Go.
\usepackage{lstlang0}
% Colores personalizados.
\usepackage{color}
\definecolor{orange}{rgb}{0.99, 0.50, 0.13}
\definecolor{carnelian}{rgb}{0.7, 0.11, 0.11}
\definecolor{cerulean}{rgb}{0.0, 0.48, 0.65}
\definecolor{royalblue}{rgb}{0.0, 0.14, 0.4}
\definecolor{shamrockgreen}{rgb}{0.0, 0.62, 0.38}
% Settings para los fragmentos de código.
\renewcommand{\lstlistingname}{Fragmento}
\lstset{
	language = go,
	numbers = left,
	%Keywords
	keywordstyle = {[1]\color{orange}\bfseries},
	%Funciones
	keywordstyle = {[2]\color{shamrockgreen}\bfseries},
	%Tipos
	keywordstyle = {[3]\color{royalblue}},
	stringstyle = \color{carnelian},
	commentstyle = \color{cerulean},
	frame = tb,
	showstringspaces = false,
	breaklines = true,
	escapeinside={\%*}{*)},
	extendedchars=true,
	literate = {ô}{{\^{o}}}1 {ó}{{\'{o}}}1 {á}{{\'{a}}}1 {é}{{\'{e}}}1 {í}{{\'{i}}}1 {ú}{{\'{u}}}1
}

\begin{document}

\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{./logo_fiuba_alta}
	\label{fig:logo_fiuba_alta}
\end{figure}

\title{Informe sobre GO - Teoría del Lenguaje}
\author{Cristian Gonzalez \and Tomás Arjovsky}
\date{1$^{er}$ Cuatrimestre, 2015}
\maketitle

\tableofcontents

\section{Historia}
% y un poco de lo general.
% Compilador, formateador de codigo y demas.
% Errores por no usar variables en lugar de warnings.
\section{Sintaxis Básica}
\subsection{Paquetes}
Cada archivo de código fuente, independientemente de su nombre, aclara en la primera línea a qué paquete pertenece.

Si se quiere acceder desde un paquete a otro, lo que se hace es importar su path. Por convención, los paquetes se llaman como el último elemento del path. Importar un paquete permite usar los nombres que este exporta, típicamente funciones o variables globales (al paquete). Para señalar que un elemento se exporta, su nombre comienza con mayúscula.

Un proyecto comienza a ejecutarse en la función main del paquete main.

\lstinputlisting[caption="Hello World en Go"]{codigo/helloWorld.go}

Se puede importar más de un paquete con la forma factoreada. Esta forma es utilizada también para otras keywords además de import, como var.

\begin{lstlisting}[caption=Forma Factoreada]
import (
	"fmt" 
	"math"
)
\end{lstlisting}

\subsection{Variables}
Las variables en Go son declaradas de forma inversa al C, pareciéndose más a la de Pascal. Esta decisión fue tomada por los creadores principalmente por la dificultad para entender en C los tipos compuestos con punteros y las funciones de alto orden\cite{dec}.
\begin{description}
	\item[Declaración:]\hfill \\
		\lstinline|var a,b,c int|
	\item[Inicialización en declaración:] \hfill \\
		\lstinline|var a,b,c int = 1,2,3 // Hay asignación múltiple!|
	\item[Inferencia de Tipos:] para constantes y variables. \\
		\lstinline|var c = 1 // c pasa a ser de tipo int.|
	\item[Forma Compacta:] \hfill \\
		\lstinline|c := 1 // c se declara y se asigna.|
	
	Esta forma se puede usar siempre y cuando se esté dentro de una función (main incluida). Esto se debe a que globalmente (a nivel paquete) todas las líneas deben empezar con alguna keyword. 
	\item[Forma Factoreada:] La keyword \lstinline|var| también admite forma factoreada.
\begin{lstlisting}
var (
	a = 3 // inferencia sobre constante.
	b = a // inferencia sobre variable que ya tiene tipo.
)
\end{lstlisting}
\end{description}

Al asignar en Go una variable a la otra, se asigna el valor, al estilo imperativo, con lo cual cambiar una no tendrá ningún efecto sobre la otra (como sí sucedería en los lenguajes como Java, donde las variables son referencias).

Los punteros se declaran de la forma \lstinline|var a *int|. A diferencia de C, \emph{no hay aritmética de punteros}. Esta omisión fue pensada para aumentar la seguridad (evitar direcciones ilegales) y simplificar la implementación del recolector de basura.\cite{pa}
%TODO ver el tema del make, que no se puede hacer personalizado.

\subsection{Funciones}
No se declaran a través de su tipo de retorno, como se hace en C, sino que tienen la keyword \lstinline|func|.
\begin{description}
	\item[Declaración:]\hfill \\
		\lstinline|func nombre(a tA, b tB,...) tRet {...}| 
	\item[Argumentos agrupados según tipo:] \hfill \\
		\lstinline|func nombre(a, b int) int {...}|
	\item[Retorno Múltiple:] compatible con la asignación múltiple. \\
		\lstinline|func swap(a, b int) int {return b,a}|
	\item[Return Values como variables:] se pueden modificar en el interior de la función y al final usar "return" las devuelve en el orden especificado en la firma.
\begin{lstlisting}[caption = una variable elevada al cuadrado 3 veces]
func primeros3Cuadrados.(a int) m1,m2,m3 int{
	m1 = a*a
	m2 = m1*m1
	m3 = m2*m2
	return
}
\end{lstlisting}
\end{description}

\subsection{Estructuras de Control}
\subsubsection{Loops: for}
La única estructura de control de ciclos en Go es el \lstinline|for|, que es lo suficientemente flexible y cómodo como para reemplazar al while(), do{}While() y otros. Una diferencia menor es que los paréntesis ya no se usan y las llaves son obligatorias.
\begin{description}
	\item[Forma clásica:] \hfill \\
		\lstinline|for i := 0; i < 10; i++ { fmt.Println(i) }|
	\item[Omisiones:] El pre y el post pueden no ponerse (cualquier combinación es válida). Cuando queda solo la condición de corte, se da el caso que reemplaza al while: \\
		\lstinline|for a < 1000 { a = a*a }|
	\item[range:] para operar sobre arrays y slices (más adelante se ven), se puede usar \lstinline|range|. Es una forma primitiva que, junto a la función \lstinline|len|, elimina la necesidad de máximos lógicos, constantes o variables referidas al tamaño. Se pueden omitir el índice o el valor con el operador \_:
	\begin{itemize}
	\item \lstinline|for i,v := range arreglo {fmt.Println("indice:",i,"valor:",v)}|
	\item \lstinline|for i := range arreglo {fmt.Println("indice:",i)}|
	\item \lstinline|for _,v := range arreglo {fmt.Println("valor:",v)}|
	\end{itemize}
\end{description}
\subsubsection{if}
Igual que el clásico de C o C++, solo que se sigue el mismo criterio con los paréntesis y las llaves y se puede agregar un pre (paso inicial, previo al if), al igual que en el for. De la misma forma, \emph{cualquier variable definida en el pre vivirá solo en el scope del if (y del else)}. %TODO ver si hay otra forma de decir pre y post.
\begin{lstlisting}[caption = promedio precalculado.]
// Al calcular p en el pre, no hay que calcularlo de nuevo adentro del if.
if p := prom(notas); p >= 7 {
	fmt.Println("Aprobado. Promedio:", p)
} else {
	fmt.Println("Reprobado. Promedio:", p)
}
\end{lstlisting}

\subsubsection{switch}
Se agrega un break automático al final de cada case. Entonces, a diferencia de C, para casos múltiples, en lugar de omitir un break, se hacen conjuntos separados por coma. Además, las expresiones de cada caso son más generales, ya que no necesitan ser constantes o siquiera enteros. 

\begin{lstlisting}[caption = parsear acciones de T.E.G. (switch sobre strings)]
switch accion {
	case "invadir": invadir(objetivo)
	case "reagrupar": reagrupar()
	case "pedir tarjeta", "tarjeta": sacarCarta(mazo)
	default: fmt.Println("Opción desconocida")
}
\end{lstlisting}
Si no se especifica ninguna variable en el switch se asume \lstinline|switch true|, con lo cual se evalúan expresiones booleanas. Como los casos se evalúan de arriba hacia abajo en orden, el switch a secas es una forma prolija de anidar ifs.

\begin{lstlisting}[caption = switch como ifs anidados.]
switch {
	p < 4: fmt.Println("aplazado")
	p < 7: fmt.Println("reprobado")
	default: fmt.Println("aprobado")
}
\end{lstlisting}

\subsubsection{defer}
Una función a la que se le antepone \lstinline|defer| (posponer, diferir) se ejecuta al final de la función que la contiene. Si hay \lstinline|defer| con más de una función, se ejecutan de forma LIFO.

\lstinputlisting[firstline = 5, caption = Hello World Alternativo]{codigo/defer.go}

Una gran utilidad del defer es, dentro de las funciones que tienen muchos return en distintas circunstancias, usar una función diferida que tiene que ejecutarse en todos los casos de devolución, como por ejemplo, cerrar un archivo. \cite{defer}

\section{Tipos de datos}
Go tiene tipado estático (en tiempo de compilación) y fuerte. Las variables o bien son declaradas con un cierto tipo o lo infieren de la parte derecha de una asignación, luego de lo cual no pueden cambiar su tipo. Lo más parecido a tipado dinámico son las interfaces, que se verán más adelante.

Estos son los tipos básicos de Go:
\begin{description}
\item[Booleanos:] \lstinline|bool|.
\item[Cadenas:] \lstinline|string|.
\item[Enteros:] \lstinline|int  int8  int16  int32  int64|.
\item[Sin signo:] \lstinline|uint uint8 uint16 uint32 uint64 uintptr|.
\item[Bytes:] \lstinline|byte|. Alias de uint8.
\item[Caracteres:] \lstinline|rune|. Alias de int32, se verá más adelante, representa un punto de Unicode.
\item[Flotantes:] \lstinline|float32 float64|
\item[Complejos:] \lstinline|complex64 complex128|
\end{description}

Cada tipo tiene un \emph{zero value}, que es un valor en el que se inicializa la variable si no se especifica uno al declararla. Para los valores numéricos es 0, para las strings, la cadena vacía y para estructuras complejas suele ser nil.

%TODO ver casos raros para inferencia, como variables que todavía no tienen valor, y demás.
La \emph{inferencia} es bastante simple, ya que es un lenguaje tipado. Cuando se usa el operador := con una variable del lado derecho, la del lado izquierdo adquiere su mismo tipo. 

El caso más raro es el de las constantes numéricas, que son de alta precisión y no tienen un tipo, sino que proveen el tipo necesario para las operaciones que se hagan sobre ellas. 
\lstinputlisting[caption = Constantes Comodines]{codigo/constantes.go}
El caso anterior produce el siguiente output: 
\begin{verbatim}
La variable es de tipo int y tiene valor: 5.
La variable es de tipo float32 y tiene valor: 5.
La variable es de tipo float32 y tiene valor: 5e+19.
\end{verbatim}
Esto muestra justamente lo propuesto de que la constante provee el tipo necesitado. Sin embargo, esto tiene sus excepciones, como es el caso de c2. Esta constante es un número muy grande como para  proveer un valor de tipo int, con lo cual si se quitan las barras de comentario de la última línea del main, el programa falla en tiempo de compilación: 

\begin{verbatim}
./constantes.go:20: constant 50000000000000000000 overflows int
\end{verbatim}

Como se decía antes, hay que notar que este comportamiento de comodín es \emph{solo para constantes}. La conversión de tipos entre variables es \emph{siempre explícita}.

\lstinputlisting[caption = asignación ilegal.]{codigo/variables.go}
Produce el siguiente mensaje de error:
\begin{verbatim}
./variables.go:6: cannot use entera (type int) as type float32
 in assignment
\end{verbatim}
Para hacerlo correctamente hay que explicitar la conversión:
\lstinputlisting[caption = conversión legal.]{codigo/variablesbien.go}

Si creamos tipos propios o queremos hacer funciones que conviertan de un tipo a otro que son muy distintos, podemos hacer uso de interfaces, reflexión y switches sobre tipos. Más adelante %TODO linkear
se explica este caso.

En adelante se detallan algunos tipos de datos específicos:

\subsection{Structs}
Prácticamente iguales a los de C. Para usarlos, se define un tipo basado en struct de la siguiente manera:
\begin{lstlisting}[caption = declaración de structs]
type vertice struct{
	x int
	y int
	z int
}
\end{lstlisting}

Son la forma empaquetada nativa de Go. Se pueden asignar structs literales de la siguiente forma: \lstinline| v := vertice{1,2,3}|. Se puede inicializar un campo específico (\lstinline|v := vertice{x:1, z:2}|) y los que queden sin asignar tendrán zero values.

Para acceder a sus campos se usa, por ejemplo para el x, v.x.

\paragraph{Transparencia de punteros:} los punteros a registros son transparentes para el acceso a los campos:

\begin{lstlisting}[caption = transparencia de punteros.]
pv := &vertice{10,20,30} // se crea un puntero a un vertice.
fmt.Println(pv.x) // se imprime el primer campo (10).
\end{lstlisting}
\subsection{Arrays}
La forma básica de almacenamiento secuencial. Más allá de su implementación interna, una variable que es un array, \emph{no es un puntero}. Si se hace un puntero al array no apunta a su primer elemento, si no a la variable que lo contiene (recordar que no hay aritmética de punteros).
\begin{description}
	\item[Declaracion:] \hfill \\
	\lstinline|var arr [5]int // 5 es el "element count"|\\
	Es importante tener en cuenta que el element count es parte del tipo: [5]int y [6]int son tipos diferentes.
	\item[Literales:] \hfill \\
		\lstinline|arr := [5]int{1,2,3,4,5}|
	\item[Conteo automático:] a través del operador ``...'' \\
		\lstinline|arr := [...]int{1,2,3,4,5}|
	\item[Inicialización por default:]  si a un array no se le especifican valores con una inicialización, todas sus posiciones son inicializadas en el zero value del tipo base.
	\item[Longitud:] es parte de la variable y se accede a ella con la función \lstinline|len(arr)|
\end{description}

\subsection{Slices}
Forma dinámica secuencial nativa de Go. Se llaman ``slices'' (porciones) porque una de las formas de crearlas es por ``cortando'' un array. Como son dinámicas (pueden crecer en tamaño) tienen dos atributos, longitud (\lstinline|len|) y capacidad (\lstinline|cap|). %TODO bajar redundancia acá.
\begin{description}
	\item[Creación:] al igual que otras estructuras complejas, se crean con la función \lstinline|make|, especificando la longitud (tamaño inicial) y la capacidad (hasta donde pueden crecer sin pedir memoria):
	\begin{itemize}
		\item \lstinline|s := make([]int,5)   // len=5 cap=5|
		\item \lstinline|s := make([]int,0,5) // len=0 cap=5|
	\end{itemize}
	Así como el tipo de los arrays de enteros es [n]int, el de las slices es []int, donde no se especifica el tamaño. Esto significa que una slice de 20 elementos es del mismo tipo que una de 30. El tipo de la variable a crear es siempre el primer argumento de \lstinline|make|.
	\item[Literales:] \hfill \\
		\lstinline|s := []int{1,2,3} // crea una slice de ints con len=3, cap=3|
	\item[Cortando (slicing) arrays:] se especifica el índice del primer elemento (inclusivo) y el último (no inclusivo). Esta diferencia surge de la conveniencia para ver rápidamente el tamaño de la slice restando el segundo número por el primero. O sea, si la slice tiene índices [a,b), entonces su longitud será b - a.
\begin{lstlisting}[caption = slices desde arrays]
a := [...]int{1,2,3,4,5}
s := a[2:4] // s == [3,4]
\end{lstlisting}	
\end{description}

En el caso particular de sacar slices de arrays, los datos no se duplican: los elementos de la slice corresponden a la misma porción de memoria\cite{slices}. Por lo tanto, al modificar una estructura se modifica la otra, y vice-versa. Esto, sin embargo, no hace que sean iguales, o siquiera comparables: las slices solo pueden usar el operador == con un \lstinline|nil| del otro lado. El \lstinline|nil|, justamente, es el zero value de este tipo de datos, y representa una slice vacía.

\paragraph{Re-Slice:} una slice puede ser cortada de nuevo, ya sea en porciones más pequeñas, o más grandes.
\begin{lstlisting}[caption = cortando hacia derecha o hacia izquierda.]
s1 := []int{1,2,3,4}
s2 := s1[:2] // s2 es [1,2] tiene capacidad 4.
s3 := s2[:3] // s3 es [1,2,3] con capacidad 4.
s4 := s1[2:] // s4 es [3,4] tiene capacidad 2.
\end{lstlisting}
En el caso anterior, s2 y s4 son cortes más pequeños que el original, mientras que s3 es un corte más grande (mayor \lstinline|len|) a s2, del cual viene. Una limitación:
\begin{lstlisting}[caption = re-slice ilegal.]
s1 := []int{1,2,3,4}
s2 := s1[:5]
\end{lstlisting}
Si se intentara cortar hacia afuera más allá de la capacidad, esto produce un error en tiempo de ejecución, ya que es un tipo secuencial y más allá de su capacidad puede haber memoria reservada.

\paragraph{Redimensión:} como se ha dicho, la slice es un tipo dinámico, y si se quiere aumentar la capacidad del mismo, esto se hace (internamente) creando una slice nueva con una capacidad mayor y copiando elemento a elemento\cite{slices} con la función \lstinline|copy|. Externamente, sin embargo, existe la función \lstinline|append|, que agrega un elemento al final de la slice, y si sobrepasa la capacidad, se encarga de reubicarla según lo recién descripto.
\begin{lstlisting}[caption = append]
var s1 []int // s1 == nil
s1 = append(s1, 2, 3, 5, 7) // append a un nil es como a una lista vacía.
s2 := []int{10, 20, 30}
s3 := append(s2,s1...) // el operador ... expande s1 para pasar elemento por elemento.
s3[5] = 4
fmt.Println(s1, s3)
\end{lstlisting}
Esto produce como output:
\begin{verbatim}
[2 3 5 7] [10 20 30 2 3 4 7]
\end{verbatim}
Al modificar s3[5] no se modifica s1, ya que lo que se agrega a s3 en el append no es s1 en sí, sino sus elemntos uno a uno con el operador ``...''.

Las funciones \lstinline|copy|, \lstinline|append|, \lstinline|len| y \lstinline|cap| están implementadas de forma abierta, desempaquetada y declarativa, ya que nunca se modifica el original, sino que se devuelve la versión modificada. Sin embargo, el tipo de datos posee estado mutable, lo que se ve sencillamente cambiando el valor de un elemento como en la línea 5 del anterior fragmento de código. Este estilo mixto es muy característico de los tipos de datos estructurados de Go.
\subsection{Runas y strings}
Go acepta en su código fuente cualquier caracter Unicode. En lugar de caracteres al estilo ``char'', Go tiene runes (alias de uint32), que representan Unicode points. Uno caracter de este tipo puede tener ser de hasta 4 bytes, ya que el conjunto incluye símbolos Japoneses, árabes, acentos, cirílicos, y muchos otros.

Por otro lado, contrario a muchos lenguajes, las strings no son cadenas de caracteres, si no que son cadenas de bytes (alias de uint8). Para compatibilizar la conversión ida y vuelta entre bytes individuales y puntos de Unicode, que son de 1 a 4 bytes, se usa el encoding UTF-8, que está incorporado nativamente al procesamiento del código fuente de Go.
\lstinputlisting[firstline = 5, caption = ejemplo de byte vs runa.]{codigo/runas.go}
Da como output:
\begin{verbatim}
el valor es Allô! y su longitud es 6
\end{verbatim}
Esto muestra que si bien la palabra ``Allô!'' tiene 5 caracteres, la longitud de la slice de bytes es de 6, lo cual significa que la runa ô ocupa 2 bytes. 

Para ver un detalle de la comparación, \lstinline|range| itera sobre runas, mientras que para ir byte a byte se trata a la string como un array: 
\lstinputlisting[caption = detalle de byte vs runa.]{codigo/detalleRunas.go}
Output:
\begin{verbatim}
Runas:
0: 'M', que es de tipo int32
1: 'i', que es de tipo int32
2: 'r', que es de tipo int32
3: 'á', que es de tipo int32
5: '!', que es de tipo int32
Bytes:
0: 'M', que es de tipo uint8
1: 'i', que es de tipo uint8
2: 'r', que es de tipo uint8
3: 'Ã', que es de tipo uint8
4: '¡', que es de tipo uint8
5: '!', que es de tipo uint8
\end{verbatim}
En el ejemplo anterior se ve, justamente, que si se mira byte a byte, los caracteres de más de un byte de Unicode, el output de aquellos será incomprensible. Esto es lo que ocurre cuando, por ejemplo, en una página en español no está fijado el encoding UTF-8 para traducir de secuencias de bytes a caracteres Unicode. Este encoding, no casualmente, fue inventado por Rob Pike y Ken Thomson \cite{unicode}, dos de los tres creadores del lenguaje Go.
\subsection{Mapas}
\subsection{Funciones y clausuras}

\section{Recolector de Basura}
El Recolector de Basura de Go usa una variante de \textit{marcado-y-barrido} donde en vez de usar solamente 2 colores para el marcado, usa 3. 
Acá explicamos las características de cada conjunto.
\begin{itemize}
	\item[$\bullet$] Gris:
	\item Negro: El conjunto negro es el conjunto de objetos que pueden ser mostrados por tener referencias salientes a los objetos en el conjunto blanco, y por ser accesible desde la raíz. Los negros no son candidatos a reciclar, en algunas implementaciones el conjunto negro empieza vacío. 
	\item Blanco: son aquellos que son candidatos a reciclar. En un principio todos son candidatos a reciclar. 
\end{itemize}

Otra característica importante es \textit{stop-the-world} el cual pausa, al momento de correr el recolector, todos los hilos menos aquellos que utilice el recolector hasta que finalice el mismo. 

\begin{thebibliography}{99}
\bibitem{dec} Nota en The Go Blog sobre la \href{http://blog.golang.org/gos-declaration-syntax}{sintáxis de la declaración}.
\bibitem{pa} FAQ sobre \href{https://golang.org/doc/faq#no_pointer_arithmetic}{aritmética de punteros}.
\bibitem{defer} Effective Go sobre \href{https://golang.org/doc/effective_go.html#defer}{el uso del defer}
\bibitem{slices} Go blog sobre el \href{http://blog.golang.org/go-slices-usage-and-internals}{uso y los manejos internos de las slices}.
\bibitem{unicode} Artículo de wikipedia sobre \href{https://es.wikipedia.org/wiki/UTF-8}{UTF-8}
\end{thebibliography}

\end{document}